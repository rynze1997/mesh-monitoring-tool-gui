import pandas as pd
import time
from datetime import datetime, timedelta

# Define column names based on the observed structure and assumption about the content
column_names = ['Timestamp', 'MAC', 'Command', 'Flags', 'Index', 'Payload', 'Version']

# Load your dataset
# df = pd.read_csv('.results/mdr _125ms_one_neighbor.csv')
df = pd.read_csv('.results/mdr_40ms_one_neighbor.csv')

packets_to_recheck = pd.DataFrame()

class Latency: 
    
    def __init__(self) -> None:
        self.mac_label_map = {'D4:1B:20:25:CF:1D': {'number': 1, 'title': 'Black2'}, 'E6:58:D8:31:2E:52': {'number': 2, 'title': 'White'}, 'E3:CA:10:B4:88:7A': {'number': 3, 'title': 'Yellow'}, 'FD:31:20:A8:6C:10': {'number': 4, 'title': '3'}, 'DF:DC:E7:66:CC:01': {'number': 5, 'title': 'Black'}, 'E6:11:85:7C:B5:94': {'number': 6, 'title': '2'}, 'C3:32:96:81:99:D4': {'number': 7, 'title': 'Yellow2'}}
    @staticmethod
    def get_first_occurrences(df, mac_address):
        """
        Find which packets are generated by the given MAC address.
        """

        # Group the DataFrame by 'Version', 'Index', and 'Payload' and get the first occurrence in each group
        copy_df = df.copy()
        copy_df['Payload'] = copy_df['Payload'].fillna('NoPayload')
        copy_df = copy_df.groupby(['Version', 'Index']).first().reset_index()
        
        # Filter the DataFrame to include only rows with the given MAC address
        copy_df = copy_df[copy_df['MAC'] == mac_address]

        # Convert the DataFrame to a list of Series and return it
        return copy_df

    @staticmethod
    def get_packet_timestamp(packet_timestamp: str):
        # Remove brackets and split by the dot
        parts = packet_timestamp.strip('[]').split('.')
        if len(parts) != 4:
            print(f"Invalid timestamp format: {packet_timestamp}")
            return None
        
        try:
            # Extract each part of the timestamp
            minutes, seconds, milliseconds, microseconds = [int(part) for part in parts]
            
            # Construct a timedelta since the minimum component we have is minutes
            # This timedelta represents the duration since the start of the hour
            delta = timedelta(minutes=minutes, seconds=seconds, milliseconds=milliseconds, microseconds=microseconds)
            
            # Construct a base datetime object (you might adjust this according to your needs)
            # Here we use a base date of 1st January 1970 with the hour set to 0
            base_datetime = datetime(1970, 1, 1, hour=0)
            
            # Add the timedelta to the base datetime
            final_datetime = base_datetime + delta
            return final_datetime
        except ValueError as e:
            print(f"Error parsing timestamp: {e}")
            return None
    
    def calculate_latency(self, df, source_mac, destination_mac, source_index, destination_index, node_neighbor_map):
        '''
        This function calculates Latency between two nodes. 
        Latency for a message is calculated from the time the message is transmitted on the air by the source node
        to the time any of the neighbors of the destination node rebroadcasts it.
        
            1. Find all messages that originates from the source
            2. Separate all SET, GET messages on destination Index
            3. Separate all messages that the source sent on its own index and that are not SET or GET.
            ** Messages from steps 2 and 3 are all messages that destination node should acknowledge or rebroadcast.
            ** Since we are calculating the latency up to the destination node, we are not looking for its own acknowledgements or rebroadcasts.
            ** We are looking for re-rebroadcasts of the source messages by the destination node neighbors.
            4. Find all neighbors of the destination node
            5. Find all packets that the neighbors has sent
            6. From all neighbor packets, get only those that are the same as source messages
            7. Pair all neighbor packets with their corresponding source message
            8. Drop duplicates with same MAC address. We are only interested in the first occurrence, which would be the
            soonest one.
            9. Calculate time difference between source messages and neighbor packets
            10. For each message, find the minimum and maximum time difference
            11. Calculate average latency and maximum latency
        '''
        print(f"Calculating RRT from {source_mac} to {source_mac}")
        
        # Convert timestamps to a Pandas compatible format for easy time calculations
        df['Timestamp'] = df['Timestamp'].apply(self.get_packet_timestamp)
        
        # Find all new version packets that originates from the source MAC
        source_node_messages = self.get_first_occurrences(df, source_mac)
        source_node_messages.to_csv(f'source_node_messages.csv', index=False)
        
        # Find only SET, GET messages and all other messages that are sent on the source index. 
        # These are all messages that destination node should acknowledge or rebroadcast.
        source_node_set_get_messages = source_node_messages[((source_node_messages['Flags'] == '[SET]') | (source_node_messages['Flags'] == '[GET]')) & (source_node_messages['Index'] == destination_index)]
        source_node_other_messages = source_node_messages[(source_node_messages['Flags'] != '[SET]') & (source_node_messages['Flags'] != '[GET]') & (source_node_messages['Index'] == source_index)]
        # Join all source node messages together
        all_source_node_messages = pd.concat([source_node_set_get_messages, source_node_other_messages])
        all_source_node_messages.to_csv(f'all_source_node_messages.csv', index=False)
        
        # Find all destination node neighbors
        destination_node_neighbors = node_neighbor_map[self.mac_label_map[destination_mac]['number']]
        # Get MAC addresses of all neighbors
        destination_neighbor_macs = [mac for mac, info in self.mac_label_map.items() if info['number'] in destination_node_neighbors]
        
        # Get packets that belong to destination node neighbors
        neighbor_packets = df[df['MAC'].isin(destination_neighbor_macs)]
        neighbor_packets = neighbor_packets.copy()
        neighbor_packets['Payload'] = neighbor_packets['Payload'].fillna('NoPayload')
        neighbor_packets.to_csv(f'neighbor_packets.csv', index=False)
        
        # From all neighbor packets, get only those that are the same as source messages
        criteria = all_source_node_messages[['Version', 'Index', 'Payload']]
        neighbor_packets = neighbor_packets.merge(criteria, on=['Version', 'Index', 'Payload'], how='inner')
        neighbor_packets.to_csv(f'neighbor_packets.csv', index=False)
        
        # Pair all neighbor packets with their corresponding source message
        merged_df = pd.merge(all_source_node_messages, neighbor_packets, on=['Version', 'Index', 'Payload'], how='inner')
        merged_df.to_csv(f'merged_df.csv', index=False)
        # Drop duplicates with same MAC address. We are only interested in the first occurrence, which would be the
        # soonest one.
        merged_df_mac_filtered = merged_df.drop_duplicates(subset=['Version', 'Index', 'Payload', 'MAC_y'])
        merged_df_mac_filtered.to_csv(f'merged_df_mac_filtered.csv', index=False)
        # Calculate time difference between source messages and neighbor packets
        merged_df_mac_filtered = merged_df_mac_filtered.copy()
        merged_df_mac_filtered['TimeDiff'] = (merged_df_mac_filtered['Timestamp_y'] - merged_df_mac_filtered['Timestamp_x']).dt.total_seconds() * 1000
        merged_df_mac_filtered.to_csv(f'merged_df_timediff.csv', index=False)
        
        # Group paired DataFrame by 'Version', 'Index', and 'Payload' and get the minimum and maximum time difference
        merged_df_grouped = merged_df_mac_filtered.groupby(['Version', 'Index', 'Payload'])
        merged_df_min_max = merged_df_grouped['TimeDiff'].agg(['min', 'max']).reset_index()
        merged_df_min_max.to_csv(f'merged_df_min_max.csv', index=False)
        
        # Calculate average latency and maximum latency
        avg_mdr = merged_df_min_max['min'].mean()
        max_mdr = merged_df_min_max['max'].max()
        
        print(f"Average MDR: {avg_mdr}")
        print(f"Maximum MDR: {max_mdr}")
        
        return avg_mdr, max_mdr
        
        
        
        
    

    
dest_mac = 'E6:58:D8:31:2E:52'
source_mac = 'E3:CA:10:B4:88:7A'
source_index = 215
destination_index = 217
node_neighbour_map = {1: [3, 5, 6, 2, 7, 4], 3: [1, 5, 4, 7, 6], 5: [1, 4, 7, 3, 2, 6], 2: [4, 7, 5, 6, 1], 4: [2, 5, 7, 3, 6, 1], 7: [5, 2, 4, 3, 6, 1], 6: [1, 2, 7, 5, 4, 3]}
        
latency = Latency().calculate_latency(df, source_mac, dest_mac, source_index, destination_index, node_neighbour_map)
    
    


